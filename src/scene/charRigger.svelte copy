<script context="module">
import { get } from 'svelte/store';
import { VRMSchema } from '@pixiv/three-vrm';
import { clamp,remap } from "../utils/helpers.js";
import {cameraConfig,staticCamera,freeCamera,pivotPoint} from './CameraControls.svelte'
import {options} from '../tracking/Holistic.svelte'


import * as THREE from 'three';
  
export const animateHead = (currentVrm,face) => {
  
  const Neck = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName.Neck )
  //offset from pivot
  let offsetX = (get(cameraConfig).freeCamera && !get(cameraConfig).firstPerson) ? clamp(-pivotPoint.rotation.x,-.4,.4) : 0
  
  //turn LR
  if(Neck){
    Neck.rotation.y = clamp((face.head.x/50),-.6,.6) ; 
    //lean forward/back
    Neck.rotation.x = clamp((face.head.y/90 + offsetX ),-.8,.8) 
    //lean side to side
    Neck.rotation.z = clamp((face.head.z/90),-.3,.3); 
  }

}

export const animateChest = (currentVrm,face,pose) => {
  let upperChest = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName.UpperChest )
  const Chest = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName.Chest )
  const Spine = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName.Spine )
  
  if(upperChest){
  upperChest.rotation.y = clamp((face.head.x/50*.2),-.3,.3);
  upperChest.rotation.x = clamp((face.head.y/90*.2),-.3,.3);
  upperChest.rotation.z = clamp((face.head.z/90*.8),-.3,.3);
  }

  //Note: decreased rotation to help with selfee demo
  let dampener = .1
  if(Chest){
  Chest.rotation.x = clamp((face.head.y/50*dampener),-.3,.3);
  Chest.rotation.z = clamp((face.head.z/90*dampener),-.3,.3);
  Chest.rotation.y = get(options).holistic.enable==="hi" ? clamp((pose.Spine.x/90*dampener),-.3,.3)
    : Chest.rotation.y = clamp((face.head.x/50*dampener),-.3,.3);
  }

  if(Spine){
  Spine.rotation.x = clamp((face.head.y/50*dampener),-.3,.3);
  Spine.rotation.z = clamp((face.head.z/90*dampener),-.3,.3);
  Spine.rotation.y = get(options).holistic.enable==="hi"  ? clamp((pose.Spine.x/120*dampener),-2.3,2.3)
    : Spine.rotation.y = clamp((face.head.x/50*dampener),-.3,.3);
  }

  // Spine.rotation.z = clamp((pose.Spine.z/90),-2.3,2.3);
}

export const animateFace = (currentVrm,face) => {
  
    // head angle needed to compensate for wrong geometry
    // headTurn is 0 to 1 from -12 to -16 and from 12 to 16
    let headTurn = 1-((clamp(Math.abs(face.head.x)-12,0,6))/6) 
    headTurn = 1
    //Normalize for mouth values when turning head left
    // const mouthX = clamp(face.mouth.x-.5,0,.5)/.5*headTurn
    const mouthX = remap(face.mouth.x-.4,0,.5)*headTurn

    const mouthY = face.mouth.y
    
    let eye = face.eye
    
    //Calc Joy value based on mouth X + eye closed ratio
    let joy = clamp(mouthX,0,1)*1.2
    // joy *= eye.l !== eye.r ? 0 : (1-remap(eye.l,.2,.8))
    // Warning! Joy blendshape changes both Blink and Mouth behaviors
    // Not too great for puppetteering since it controls too many variables
    // Blendshape.setValue( PresetName.Joy, joy)
  
    // Blendshapes and Preset Name Schema
    const Blendshape = currentVrm.blendShapeProxy
    const PresetName = VRMSchema.BlendShapePresetName

    //handle Wink
    if(eye.l !== eye.r){
      eye.l = clamp(1-eye.l,0,1)
      eye.r = clamp(1-eye.r,0,1)
      //Joy blendshape clashes with BlinkL and BlinkR blenshapes. Reset Joy
      joy = 0
      
      Blendshape.setValue( PresetName.Blink, 0 )
      Blendshape.setValue( PresetName.BlinkL, eye.l )
      Blendshape.setValue( PresetName.BlinkR, eye.r )
    }else{
      //Blink blendshape needs to compensate for the eye warping from Joy blendshape
      const stabilizedBlink = clamp((1-eye.l),0,1)
      Blendshape.setValue( PresetName.Blink, stabilizedBlink)
      Blendshape.setValue( PresetName.BlinkL, 0)
      Blendshape.setValue( PresetName.BlinkR, 0)
      
      //  Blendshape.setValue( PresetName.BlinkL, stabilizedBlink )
      // Blendshape.setValue( PresetName.BlinkR, stabilizedBlink )
    }

  
    Blendshape.setValue( PresetName.I, face.mouth.shape.I );
    Blendshape.setValue( PresetName.A, face.mouth.shape.A );
    Blendshape.setValue( PresetName.E, face.mouth.shape.E );
    Blendshape.setValue( PresetName.O, face.mouth.shape.O );
    Blendshape.setValue( PresetName.U, face.mouth.shape.U );
  
    //PUPILS
    //lookat method accepts Three.euler objects
    let lookMax = 1
    currentVrm.lookAt.applyer.lookAt(new THREE.Euler( clamp(lookMax * .7 * face.pupil.y, -.6 , .6), lookMax* face.pupil.x , 0, 'XYZ' ))
}

export const animateArm = (currentVrm,pose,side="Right",flipHorizontal = false) => {
    //Values invert based on left/right side
    let invert = side === 'Right' ? 1 : -1 
    let flipAgain = flipHorizontal ? -1 : 1;
  
    let targetSide = flipHorizontal && side === "Right" ? "Left" 
        : flipHorizontal && side === "Left" ? "Right" 
        : side
    const Shoulder = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'Shoulder'] )
    const UpperArm = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'UpperArm'] )
    const LowerArm = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'LowerArm'] )
    const Hand = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'Hand'] )

    // Shoulder.rotation.z = 0 * invert ;
    // Shoulder.rotation.y = 0 * invert;
    // if(Shoulder){
    // Shoulder.rotation.x = clamp(pose[side+'UpperArm'].y * -1, -1.3, 1.3) * invert;
    // }
  
    UpperArm.rotation.z = pose[side+'UpperArm'].z * -2.3 / 180 * invert ;
    UpperArm.rotation.y = pose[side+'UpperArm'].y * 2.3 / 180* invert;
    if(flipHorizontal){
      UpperArm.rotation.y += (pose[side+'LowerArm'].x * 1/180)
      UpperArm.rotation.y += (-invert*Math.max(pose[side+'LowerArm'].z,0) * 1/180) 
    }else{
      UpperArm.rotation.y -= (pose[side+'LowerArm'].x * 1/180)
      UpperArm.rotation.y -= (-invert*Math.max(pose[side+'LowerArm'].z,0) * 1/180) 
    }
   
  
    UpperArm.rotation.x = pose[side+'UpperArm'].x * 2.3 / 180 * invert;
    UpperArm.rotation.x = flipHorizontal ? 
      clamp(UpperArm.rotation.x,-Math.PI,Math.PI)
      : clamp(UpperArm.rotation.x, -.5,Math.PI)

    LowerArm.rotation.z = pose[side+'LowerArm'].z * -3.14/180 * invert;
    LowerArm.rotation.y = pose[side+'LowerArm'].y * 2.4/180 * invert ; 
    LowerArm.rotation.x =pose[side+'LowerArm'].x * 2.14/180* invert * flipAgain; //prob need to adjust X
    Hand.rotation.z = ((pose[side+'Hand'].z * -2.3/180)) * invert ; //up down
    // Hand.rotation.x = clamp(pose[side+'Hand'].x * 2/180 * invert,-.3,.3) ; // twist
    // Hand.rotation.y = clamp(pose[side+'Hand'].y * 3/180,-.6,.6); //side to side
}

export const animateFingers = (currentVrm,hand,side="Right") => {
    const invert = side === 'Right' ? 1 : -1 
    let digits = ['Ring','Index','Little','Thumb','Middle']
    let segments = ['Proximal','Intermediate','Distal']
    const Hand = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'Hand'] )
    if(Hand){
      Hand.rotation.x = clamp(hand[side+'Wrist'].x * 2/180 * invert,-.3,.3) ; // twist
      Hand.rotation.y = clamp(hand[side+'Wrist'].z * 3/180,-.6,.6); //side to side
    }
    digits.forEach(e=>{
      
      segments.forEach(j=>{
        
        const Finger = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+e+j] )
        if(!Finger){
          return
        }
        const trackedFinger = hand[side+e+j]
        const isThumb = e==='Thumb' ? -1 : 1;
        
        if(e==='Thumb'){
          //dampen thumb rotation depending on segment
          let dampener = {
            x:j === 'Proximal' ? 1.5 
              : j === 'Intermediate' ? 0 
              : 0,
            y:j === 'Proximal' ? 1.5 
              : j === 'Intermediate' ? .7 
              : 1,
            z:j === 'Proximal' ? .5 
              : j === 'Intermediate' ? 0.5 
              : 0.5
          }
          let startPos = {
            x:j==="Proximal" ? 1.2 : j==="Distal" ? -.2 : -.2,
            y:j==="Proximal" ? 1.1*invert : j==="Distal" ? .1*invert  : .1*invert,
            z:j==="Proximal" ? .2*invert : j==="Distal" ? .2*invert  : .2*invert
          }
          if(j==="Proximal"){
            Finger.rotation.z = clamp(startPos.z+trackedFinger.z/180 * -Math.PI*dampener.z  * invert, 
                                    -2.3,
                                    2.3);
            Finger.rotation.x = clamp(startPos.x+trackedFinger.z/180 * -Math.PI*dampener.x, 
                                    -2.3,
                                    .1);
            Finger.rotation.y = clamp(startPos.y+trackedFinger.z/180 * -Math.PI*dampener.y  * invert,
                                    side==="Right" ? -2.3 : -.1,
                                    side==="Right" ? .1 :2.3);
          }else{
            Finger.rotation.z = clamp(startPos.z+trackedFinger.z/180 * -Math.PI*dampener.z  * invert, 
                                    -2.3,
                                    2.3);
            Finger.rotation.x = clamp(startPos.x+trackedFinger.z/180 * -Math.PI*dampener.x, 
                                    -2.3,
                                    2.3);
            Finger.rotation.y = clamp(startPos.y+trackedFinger.z/180 * -Math.PI*dampener.y  * invert,
                                    -2.3,
                                    2.3);
          }
          

        }else{
          //will document human limits later 
          Finger.rotation.z = clamp(trackedFinger.z/180 * -Math.PI * invert,side==="Right" ? -2.3 : 0,side==="Right" ? 0 : 2.3);
          Finger.rotation.z = clamp(trackedFinger.z/180 * -Math.PI * invert,side==="Right" ? -2.3 : 0,side==="Right" ? 0 : 2.3); 
          Finger.rotation.z = clamp(trackedFinger.z/180 * -Math.PI*invert,side==="Right" ? -2.3 : 0,side==="Right" ? 0 : 2.3);
        }

      })
    })
}

const bendXMult = .85
const posXMult = bendXMult/6

export const animateLegs = (currentVrm,face,side="Right") => {
  const inverse = side === "Right" ? 1 : -1;
  const UpperLeg = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'UpperLeg'] )
  const LowerLeg = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'LowerLeg'] )
  const Foot = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName[side+'Foot'] )
  //counter rotate against hip movement
  UpperLeg.rotation.z = .015*inverse //starting stance
  UpperLeg.rotation.z = UpperLeg.rotation.z + clamp((face.head.z/90),-1.3,1.3)*-.3;  
  UpperLeg.rotation.x = clamp((face.head.y/90),-1,0)*-bendXMult;   
  
  let dampener = .5
  UpperLeg.rotation.y = clamp((face.head.x/50*dampener),-1.3,1.3)*-bendXMult;
 
  
  LowerLeg.rotation.x = clamp((face.head.y/90),-1,0)*bendXMult*2; 
  Foot.rotation.x = clamp((face.head.y/90),-1,0)*-bendXMult; 
}

export const animateHips = (currentVrm,face) => {
  const Hips = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName.Hips )
  const Spine = currentVrm.humanoid.getBoneNode( VRMSchema.HumanoidBoneName.Spine )
  let dampener = .2

  //rotate hip based on head turn to simulate more natural 
  Hips.position.y = currentVrm.humanoid.restPose.hips.position[1] - clamp((face.head.y/90),-1,0)*-posXMult;  
  
  Hips.rotation.z = clamp((face.head.z/90),-1.3,1.3)*.3
  Hips.rotation.x = clamp((face.head.y/50*dampener),-1.3,1.3)*-bendXMult*.1;
  // Hips.rotation.y = Math.PI + clamp((face.head.x/50*dampener),-1.3,1.3)*.75
    
  Hips.rotation.y = Math.PI + clamp(Spine.rotation.y,-1.3,1.3)*.75
}


</script>

